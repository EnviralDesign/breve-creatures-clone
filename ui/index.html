<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Breve Creatures Clone</title>
  <style>
    :root {
      --hud: rgba(10, 15, 11, 0.72);
      --hud-border: rgba(183, 208, 112, 0.35);
      --hud-text: #d2f09f;
      --hud-subtle: #9fbc7e;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #1f2622;
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      color: var(--hud-text);
    }

    #app {
      display: block;
      width: 100%;
      height: 100%;
    }

    #hud {
      position: fixed;
      left: 14px;
      top: 14px;
      min-width: 245px;
      padding: 11px 13px 10px;
      background: var(--hud);
      border: 1px solid var(--hud-border);
      border-radius: 10px;
      backdrop-filter: blur(3px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
      line-height: 1.33;
      letter-spacing: 0.3px;
      user-select: none;
    }

    .panelTop {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
      font-size: 11px;
      letter-spacing: 0.38px;
      text-transform: uppercase;
      color: #c7e6a4;
    }

    .panelTopActions {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .panelSelect {
      background: rgba(0, 0, 0, 0.32);
      color: var(--hud-text);
      border: 1px solid rgba(183, 208, 112, 0.35);
      border-radius: 6px;
      padding: 2px 5px;
      font-size: 11px;
      letter-spacing: 0.2px;
      max-width: 145px;
    }

    .panelToggle {
      background: rgba(17, 28, 18, 0.92);
      color: #d4efaa;
      border: 1px solid rgba(176, 206, 110, 0.4);
      border-radius: 6px;
      padding: 2px 7px;
      font-size: 10px;
      cursor: pointer;
      text-transform: none;
      letter-spacing: 0.2px;
    }

    .panelToggle:hover {
      background: rgba(30, 46, 31, 0.95);
    }

    .panelToggle:active {
      transform: translateY(1px);
    }

    #hud.collapsed {
      padding-bottom: 8px;
    }

    #hud.collapsed #hudBody {
      display: none;
    }

    #hud .label {
      color: var(--hud-subtle);
      margin-right: 5px;
    }

    #hud .hint {
      margin-top: 6px;
      font-size: 12px;
      color: #b5cf95;
      opacity: 0.86;
    }

    #hud .ctrl {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 6px;
      font-size: 12px;
      color: #c6dfa7;
    }

    #hud input[type="range"] {
      width: 120px;
    }

    #hud select {
      background: rgba(0, 0, 0, 0.32);
      color: var(--hud-text);
      border: 1px solid rgba(183, 208, 112, 0.35);
      border-radius: 6px;
      padding: 2px 5px;
    }

    #hud button {
      background: rgba(17, 28, 18, 0.92);
      color: #d4efaa;
      border: 1px solid rgba(176, 206, 110, 0.4);
      border-radius: 6px;
      padding: 3px 7px;
      font-size: 11px;
      cursor: pointer;
    }

    #hud button:hover {
      background: rgba(30, 46, 31, 0.95);
    }

    #hud button:active {
      transform: translateY(1px);
    }

    #genomePanel {
      position: fixed;
      right: 14px;
      top: 14px;
      width: 388px;
      padding: 10px;
      background: rgba(10, 15, 11, 0.72);
      border: 1px solid rgba(183, 208, 112, 0.35);
      border-radius: 10px;
      backdrop-filter: blur(3px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
      user-select: none;
    }

    #genomePanel.collapsed {
      width: auto;
      min-width: 245px;
    }

    #genomePanel.collapsed #genomeBody {
      display: none;
    }

    #genomeTitle {
      font-size: 12px;
      letter-spacing: 0.45px;
      text-transform: uppercase;
      color: #c7e6a4;
      margin-bottom: 0;
      flex: 1 1 auto;
      min-width: 0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    #genomeCanvas {
      width: 100%;
      height: 390px;
      display: block;
      border: 1px solid rgba(180, 201, 115, 0.22);
      border-radius: 8px;
      background: radial-gradient(circle at 30% 20%, rgba(94, 134, 90, 0.08), rgba(0, 0, 0, 0.16));
    }

    #genomeMeta {
      margin-top: 6px;
      font-size: 11px;
      color: #b9d698;
      line-height: 1.35;
      letter-spacing: 0.22px;
    }

    #fitnessHistoryPanel {
      position: fixed;
      left: 14px;
      right: 14px;
      bottom: 14px;
      min-height: 214px;
      padding: 10px;
      background: rgba(10, 15, 11, 0.72);
      border: 1px solid rgba(183, 208, 112, 0.35);
      border-radius: 10px;
      backdrop-filter: blur(3px);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
      user-select: none;
    }

    #fitnessHistoryPanel.collapsed {
      min-height: auto;
      width: auto;
      right: auto;
      min-width: 245px;
    }

    #fitnessHistoryPanel.collapsed #fitnessHistoryBody {
      display: none;
    }

    #fitnessHistoryCanvas {
      width: 100%;
      height: 170px;
      display: block;
      border: 1px solid rgba(180, 201, 115, 0.22);
      border-radius: 8px;
      background: radial-gradient(circle at 22% 18%, rgba(94, 134, 90, 0.08), rgba(0, 0, 0, 0.16));
    }

    #fitnessHistoryMeta {
      margin-top: 6px;
      font-size: 11px;
      color: #b9d698;
      line-height: 1.35;
      letter-spacing: 0.22px;
    }

    @media (max-width: 980px) {
      #genomePanel {
        width: 320px;
      }

      #genomeCanvas {
        height: 320px;
      }

      #fitnessHistoryCanvas {
        height: 154px;
      }
    }
  </style>
</head>

<body>
  <canvas id="app"></canvas>
  <div id="hud">
    <div class="panelTop">
      <span>Evolution Controls</span>
      <button id="toggleHudBtn" class="panelToggle" type="button">Hide</button>
    </div>
    <div id="hudBody">
      <div><span class="label">Generation:</span><span id="gen">1</span> (<span id="champIndex">1</span>/<span
          id="pop">16</span>)</div>
      <div><span class="label">Best score:</span><span id="bestEver">0.00</span></div>
      <div><span class="label">Current score:</span><span id="bestNow">0.00</span></div>
      <div><span class="label">Trial:</span><span id="trialInfo">1/1</span></div>
      <div><span class="label">Time left:</span><span id="timeLeft">0.0</span>s</div>
      <div><span class="label">Sim rate:</span><span id="simRate">1.00x</span></div>
      <div><span class="label">Queued batch:</span><span id="queuedPop">none</span></div>
      <div><span class="label">Fast skip:</span><span id="fastSkipStatus">off</span></div>
      <div><span class="label">Satellites:</span><span id="satellites">none</span></div>
      <div class="ctrl">
        Evolution
        <button id="pauseResumeBtn" type="button">Pause</button>
        <button id="restartBtn" type="button">Restart</button>
      </div>
      <div class="ctrl">
        Genomes
        <button id="exportBestBtn" type="button">Export best</button>
        <button id="exportCurrentBtn" type="button">Export current</button>
        <button id="importGenomeBtn" type="button">Import</button>
        <input id="importGenomeInput" type="file" accept=".json,application/json" multiple style="display:none">
      </div>
      <div class="ctrl">
        Checkpoint
        <button id="saveCheckpointBtn" type="button">Save</button>
        <button id="loadCheckpointBtn" type="button">Load latest</button>
      </div>
      <label class="ctrl">
        Batch size
        <input id="populationSlider" type="range" min="1" max="384" step="1" value="160">
        <span id="populationSliderValue">160</span>
      </label>
      <label class="ctrl">
        Speed
        <select id="speedSelect">
          <option value="1" selected>1x</option>
          <option value="1.5">1.5x</option>
          <option value="2">2x</option>
          <option value="3">3x</option>
          <option value="4">4x</option>
          <option value="6">6x</option>
          <option value="8">8x</option>
        </select>
      </label>
      <div class="ctrl">
        Fast-forward gens
        <button id="skip1Btn" type="button">+1</button>
        <button id="skip10Btn" type="button">+10</button>
        <button id="skip50Btn" type="button">+50</button>
        <button id="skip100Btn" type="button">+100</button>
        <button id="skip200Btn" type="button">+200</button>
        <button id="skip500Btn" type="button">+500</button>
        <button id="skipStopBtn" type="button">Stop</button>
      </div>
      <div class="hint">Space: pause | Drag: temporary manual camera</div>
    </div>
  </div>
  <div id="genomePanel">
    <div class="panelTop">
      <span id="genomeTitle">Champion Genome Network</span>
      <div class="panelTopActions">
        <select id="genomeVizMode" class="panelSelect" aria-label="Genome analysis source">
          <option value="current" selected>Current</option>
          <option value="best">Best</option>
        </select>
        <button id="toggleGenomeBtn" class="panelToggle" type="button">Hide</button>
      </div>
    </div>
    <div id="genomeBody">
      <canvas id="genomeCanvas"></canvas>
      <div id="genomeMeta">No champion yet.</div>
    </div>
  </div>
  <div id="fitnessHistoryPanel">
    <div class="panelTop">
      <span>Fitness History</span>
      <button id="toggleFitnessHistoryBtn" class="panelToggle" type="button">Hide</button>
    </div>
    <div id="fitnessHistoryBody">
      <canvas id="fitnessHistoryCanvas"></canvas>
      <div id="fitnessHistoryMeta">Waiting for generation results...</div>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.1/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { OutputPass } from "three/addons/postprocessing/OutputPass.js";

    const DEFAULT_POPULATION_SIZE = 160;
    const MIN_POPULATION_SIZE = 1;
    const MAX_POPULATION_SIZE = 384;
    const GENERATION_SECONDS = 16;
    const DEFAULT_TRIALS_PER_CANDIDATE = 3;
    const MAX_TRIALS_PER_CANDIDATE = 3;
    const MAX_FRAME_DELTA = 0.05;
    const MAX_SIM_SPEED = 8;
    const BACKEND_HTTP_URL = window.location.origin;
    const BACKEND_WS_SCHEME = window.location.protocol === "https:" ? "wss" : "ws";
    const BACKEND_WS_BASE = `${BACKEND_WS_SCHEME}://${window.location.host}`;
    const BACKEND_EVOLUTION_WS_URL = `${BACKEND_WS_BASE}/api/evolution/ws`;
    const BACKEND_EVOLUTION_CONTROL_URL = `${BACKEND_HTTP_URL}/api/evolution/control`;
    const BACKEND_EVOLUTION_GENOME_CURRENT_URL = `${BACKEND_HTTP_URL}/api/evolution/genome/current`;
    const BACKEND_EVOLUTION_GENOME_BEST_URL = `${BACKEND_HTTP_URL}/api/evolution/genome/best`;
    const BACKEND_EVOLUTION_GENOME_IMPORT_URL = `${BACKEND_HTTP_URL}/api/evolution/genome/import`;
    const BACKEND_EVOLUTION_CHECKPOINT_SAVE_URL = `${BACKEND_HTTP_URL}/api/evolution/checkpoint/save`;
    const BACKEND_EVOLUTION_CHECKPOINT_LOAD_URL = `${BACKEND_HTTP_URL}/api/evolution/checkpoint/load`;
    const BACKEND_EVOLUTION_STATE_URL = `${BACKEND_HTTP_URL}/api/evolution/state`;
    const BACKEND_EVOLUTION_HISTORY_URL = `${BACKEND_HTTP_URL}/api/evolution/history`;

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x76817b, 55, 430);

    const renderer = new THREE.WebGLRenderer({
      canvas: document.getElementById("app"),
      antialias: true,
      powerPreference: "high-performance",
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;

    const camera = new THREE.PerspectiveCamera(52, window.innerWidth / window.innerHeight, 0.1, 700);
    camera.position.set(18, 11, 22);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.075;
    controls.maxPolarAngle = Math.PI * 0.47;
    controls.minDistance = 9;
    controls.maxDistance = 130;
    controls.enablePan = false;

    const composer = new EffectComposer(renderer);
    composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    composer.addPass(new OutputPass());

    const populationLabel = document.getElementById("pop");
    const generationLabel = document.getElementById("gen");
    const championLabel = document.getElementById("champIndex");
    const bestEverLabel = document.getElementById("bestEver");
    const bestNowLabel = document.getElementById("bestNow");
    const trialInfoLabel = document.getElementById("trialInfo");
    const timeLeftLabel = document.getElementById("timeLeft");
    const simRateLabel = document.getElementById("simRate");
    const queuedPopLabel = document.getElementById("queuedPop");
    const fastSkipStatusLabel = document.getElementById("fastSkipStatus");
    const satellitesLabel = document.getElementById("satellites");
    const populationSlider = document.getElementById("populationSlider");
    const populationSliderValue = document.getElementById("populationSliderValue");
    const speedSelect = document.getElementById("speedSelect");
    const genomeVizModeSelect = document.getElementById("genomeVizMode");
    const genomePanel = document.getElementById("genomePanel");
    const genomeCanvas = document.getElementById("genomeCanvas");
    const genomeMeta = document.getElementById("genomeMeta");
    const genomeTitle = document.getElementById("genomeTitle");
    const genomeCtx = genomeCanvas.getContext("2d");
    const fitnessHistoryPanel = document.getElementById("fitnessHistoryPanel");
    const fitnessHistoryCanvas = document.getElementById("fitnessHistoryCanvas");
    const fitnessHistoryMeta = document.getElementById("fitnessHistoryMeta");
    const toggleFitnessHistoryBtn = document.getElementById("toggleFitnessHistoryBtn");
    const fitnessHistoryCtx = fitnessHistoryCanvas.getContext("2d");
    const skip1Btn = document.getElementById("skip1Btn");
    const skip10Btn = document.getElementById("skip10Btn");
    const skip50Btn = document.getElementById("skip50Btn");
    const skip100Btn = document.getElementById("skip100Btn");
    const skip200Btn = document.getElementById("skip200Btn");
    const skip500Btn = document.getElementById("skip500Btn");
    const skipStopBtn = document.getElementById("skipStopBtn");
    const pauseResumeBtn = document.getElementById("pauseResumeBtn");
    const restartBtn = document.getElementById("restartBtn");
    const exportBestBtn = document.getElementById("exportBestBtn");
    const exportCurrentBtn = document.getElementById("exportCurrentBtn");
    const importGenomeBtn = document.getElementById("importGenomeBtn");
    const importGenomeInput = document.getElementById("importGenomeInput");
    const saveCheckpointBtn = document.getElementById("saveCheckpointBtn");
    const loadCheckpointBtn = document.getElementById("loadCheckpointBtn");
    const toggleHudBtn = document.getElementById("toggleHudBtn");
    const toggleGenomeBtn = document.getElementById("toggleGenomeBtn");
    const hud = document.getElementById("hud");
    let minPopulationSize = MIN_POPULATION_SIZE;
    let maxPopulationSize = MAX_POPULATION_SIZE;
    let defaultPopulationSize = DEFAULT_POPULATION_SIZE;
    let defaultTrialCount = DEFAULT_TRIALS_PER_CANDIDATE;
    let maxTrialCount = MAX_TRIALS_PER_CANDIDATE;
    let generationSeconds = GENERATION_SECONDS;
    let minRunSpeed = 0.5;
    let maxRunSpeed = MAX_SIM_SPEED;

    populationSlider.min = String(minPopulationSize);
    populationSlider.max = String(maxPopulationSize);
    populationSlider.value = String(defaultPopulationSize);
    populationSliderValue.textContent = String(defaultPopulationSize);
    speedSelect.value = "1";
    genomeVizModeSelect.value = "current";
    populationLabel.textContent = String(defaultPopulationSize);
    queuedPopLabel.textContent = "none";
    fastSkipStatusLabel.textContent = "off";
    satellitesLabel.textContent = "none";
    trialInfoLabel.textContent = `1/${defaultTrialCount}`;

    let population = [];
    let currentAttemptIndex = 0;
    let currentTrialIndex = 0;
    let populationSize = defaultPopulationSize;
    let pendingPopulationSize = defaultPopulationSize;
    let generation = 1;
    let trialsPerCandidate = defaultTrialCount;
    let generationClock = 0;
    let simClock = 0;
    let bestEverScore = 0;
    let currentGenomeSnapshot = null;
    let bestGenomeSnapshot = null;
    let fastForwardGenerationsRemaining = 0;
    let backendOfflineReason = "";
    let backendFastForwardBusy = false;
    let evolutionSocket = null;
    let evolutionReconnectTimer = null;
    let evolutionConnected = false;
    let injectionQueueCount = 0;
    let connectedSatellites = [];
    let lastCheckpointId = "";
    let hudCollapsed = false;
    let genomeCollapsed = false;
    let fitnessHistoryCollapsed = false;
    let simSpeed = 1;
    let effectiveSimSpeed = 1;
    let genomeVizMode = "current";
    let paused = false;
    let cameraManualUntil = 0;
    let fitnessHistory = [];
    let fitnessHistoryFetchToken = 0;
    let fitnessHistoryRefreshInFlight = false;
    let lastKnownGeneration = generation;
    let sunLight = null;
    const sunOffset = new THREE.Vector3(56, 74, 34);
    const sunTargetPos = new THREE.Vector3();
    const sunDesiredPos = new THREE.Vector3();

    createSky();
    createTerrain();
    createOriginMarker();
    createLighting();
    setGenomeVizVisibility(true);

    window.addEventListener("resize", onResize);
    renderer.domElement.addEventListener("pointerdown", markManualCamera, { passive: true });
    renderer.domElement.addEventListener("wheel", markManualCamera, { passive: true });
    populationSlider.addEventListener("input", () => {
      populationSliderValue.textContent = populationSlider.value;
    });
    populationSlider.addEventListener("change", () => {
      pendingPopulationSize = clamp(parseInt(populationSlider.value, 10), minPopulationSize, maxPopulationSize);
      populationSliderValue.textContent = String(pendingPopulationSize);
      void sendEvolutionControl({ action: "set_population_size", populationSize: pendingPopulationSize });
    });
    speedSelect.addEventListener("change", () => {
      simSpeed = clamp(parseFloat(speedSelect.value), minRunSpeed, maxRunSpeed);
      void sendEvolutionControl({
        action: "set_run_speed",
        runSpeed: simSpeed,
      });
    });
    genomeVizModeSelect.addEventListener("change", () => {
      genomeVizMode = genomeVizModeSelect.value === "best" ? "best" : "current";
      setGenomeVizVisibility(true);
    });
    skip1Btn.addEventListener("click", () => queueFastForward(1));
    skip10Btn.addEventListener("click", () => queueFastForward(10));
    skip50Btn.addEventListener("click", () => queueFastForward(50));
    skip100Btn.addEventListener("click", () => queueFastForward(100));
    skip200Btn.addEventListener("click", () => queueFastForward(200));
    skip500Btn.addEventListener("click", () => queueFastForward(500));
    skipStopBtn.addEventListener("click", stopFastForward);
    pauseResumeBtn.addEventListener("click", () => {
      void sendEvolutionControl({ action: paused ? "resume" : "pause" });
    });
    restartBtn.addEventListener("click", () => {
      const accepted = window.confirm("Restart will reset backend evolution progress. Continue?");
      if (accepted) {
        void sendEvolutionControl({ action: "restart" });
      }
    });
    exportBestBtn.addEventListener("click", () => {
      void exportGenome(BACKEND_EVOLUTION_GENOME_BEST_URL, "best-genome");
    });
    exportCurrentBtn.addEventListener("click", () => {
      void exportGenome(BACKEND_EVOLUTION_GENOME_CURRENT_URL, "current-genome");
    });
    importGenomeBtn.addEventListener("click", () => {
      importGenomeInput.click();
    });
    importGenomeInput.addEventListener("change", () => {
      void importGenomesFromFiles();
    });
    saveCheckpointBtn.addEventListener("click", () => {
      void saveCheckpoint();
    });
    loadCheckpointBtn.addEventListener("click", () => {
      const accepted = window.confirm("Load latest checkpoint into backend evolution?");
      if (accepted) {
        void loadLatestCheckpoint();
      }
    });
    toggleHudBtn.addEventListener("click", () => {
      setHudCollapsed(!hudCollapsed);
    });
    toggleGenomeBtn.addEventListener("click", () => {
      setGenomeCollapsed(!genomeCollapsed);
    });
    toggleFitnessHistoryBtn.addEventListener("click", () => {
      setFitnessHistoryCollapsed(!fitnessHistoryCollapsed);
    });
    window.addEventListener("keydown", (event) => {
      if (event.code === "Space") {
        event.preventDefault();
        void sendEvolutionControl({ action: paused ? "resume" : "pause" });
      }
    });

    let previousTime = performance.now() * 0.001;
    setHudCollapsed(false);
    setGenomeCollapsed(false);
    setFitnessHistoryCollapsed(false);
    resizeFitnessHistoryCanvas();

    function animate(nowMs) {
      requestAnimationFrame(animate);

      const now = nowMs * 0.001;
      const frameDelta = Math.min(MAX_FRAME_DELTA, now - previousTime);
      previousTime = now;

      effectiveSimSpeed = paused ? 0 : simSpeed;
      for (const creature of population) {
        creature.advancePlayback(frameDelta, effectiveSimSpeed);
      }
      syncBackendPlaybackClock();

      const champion = getChampion();
      const currentCandidate = getCurrentCandidate();
      const bestCandidate = getBestCandidate();
      updateCamera(frameDelta, champion);
      updateSunShadowRig(frameDelta);
      updateHud(champion);
      renderGenomeViz(bestCandidate, currentCandidate);
      composer.render();
    }

    requestAnimationFrame(animate);

    function queueFastForward(generations) {
      const count = Math.max(0, generations | 0);
      if (count <= 0) return;
      void sendEvolutionControl({
        action: "queue_fast_forward",
        fastForwardGenerations: count,
      });
    }

    function stopFastForward() {
      void sendEvolutionControl({ action: "stop_fast_forward" });
    }

    async function sendEvolutionControl(payload) {
      try {
        const response = await fetch(BACKEND_EVOLUTION_CONTROL_URL, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!response.ok) {
          throw new Error(`control request failed (${response.status})`);
        }
        const status = await response.json();
        applyEvolutionStatus(status);
      } catch (error) {
        console.error("evolution control failed", error);
      }
    }

    async function exportGenome(url, prefix) {
      try {
        const response = await fetch(url, { method: "GET" });
        if (!response.ok) {
          throw new Error(`export failed (${response.status})`);
        }
        const genome = await response.json();
        const stamp = new Date().toISOString().replace(/[:.]/g, "-");
        const blob = new Blob([JSON.stringify(genome, null, 2)], { type: "application/json" });
        const href = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = href;
        a.download = `${prefix}-${stamp}.json`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(href);
      } catch (error) {
        console.error("genome export failed", error);
      }
    }

    function extractGenomesFromObject(value) {
      if (!value) return [];
      if (Array.isArray(value)) {
        return value.filter(isGenomeShape);
      }
      if (Array.isArray(value.genomes)) {
        return value.genomes.filter(isGenomeShape);
      }
      if (value.genome && isGenomeShape(value.genome)) {
        return [value.genome];
      }
      if (isGenomeShape(value)) {
        return [value];
      }
      return [];
    }

    function isGenomeShape(value) {
      return Boolean(
        value &&
        typeof value === "object" &&
        value.torso &&
        Array.isArray(value.limbs)
      );
    }

    async function importGenomesFromFiles() {
      const files = Array.from(importGenomeInput.files || []);
      importGenomeInput.value = "";
      if (files.length === 0) return;
      const genomes = [];
      for (const file of files) {
        try {
          const text = await file.text();
          const parsed = JSON.parse(text);
          const extracted = extractGenomesFromObject(parsed);
          genomes.push(...extracted);
        } catch (error) {
          console.error(`failed parsing import file ${file.name}`, error);
        }
      }
      if (genomes.length === 0) {
        console.warn("no valid genomes found in selected files");
        return;
      }
      try {
        const response = await fetch(BACKEND_EVOLUTION_GENOME_IMPORT_URL, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({
            genomes,
            mutationMode: "none",
          }),
        });
        if (!response.ok) {
          throw new Error(`import failed (${response.status})`);
        }
      } catch (error) {
        console.error("genome import failed", error);
      }
    }

    async function saveCheckpoint() {
      try {
        const suggested = `gen-${generation}`;
        const name = window.prompt("Checkpoint name (optional):", suggested) || "";
        const response = await fetch(BACKEND_EVOLUTION_CHECKPOINT_SAVE_URL, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ name }),
        });
        if (!response.ok) {
          throw new Error(`checkpoint save failed (${response.status})`);
        }
        const payload = await response.json();
        lastCheckpointId = payload.id || "";
        saveCheckpointBtn.title = lastCheckpointId ? `Last saved: ${lastCheckpointId}` : "";
      } catch (error) {
        console.error("checkpoint save failed", error);
      }
    }

    async function loadLatestCheckpoint() {
      try {
        const response = await fetch(BACKEND_EVOLUTION_CHECKPOINT_LOAD_URL, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({}),
        });
        if (!response.ok) {
          throw new Error(`checkpoint load failed (${response.status})`);
        }
        const payload = await response.json();
        lastCheckpointId = payload.id || "";
        loadCheckpointBtn.title = lastCheckpointId ? `Last loaded: ${lastCheckpointId}` : "";
        await refreshFitnessHistoryFromBackend();
      } catch (error) {
        console.error("checkpoint load failed", error);
      }
    }

    function normalizeFitnessHistoryEntry(source) {
      if (!source || typeof source !== "object") return null;
      const generationRaw = source.generation ?? source.generationIndex ?? source.generation_index;
      const generationValue = Number(generationRaw);
      if (!Number.isFinite(generationValue)) return null;
      const generationIndex = Math.max(1, generationValue | 0);
      const attemptsRaw = source.attemptFitnesses ?? source.attempt_fitnesses;
      const attemptFitnesses = Array.isArray(attemptsRaw)
        ? attemptsRaw
          .map((value) => Number(value))
          .filter((value) => Number.isFinite(value))
        : [];
      const bestRaw = Number(source.bestFitness ?? source.best_fitness);
      const bestFromAttempts = attemptFitnesses.length > 0
        ? attemptFitnesses.reduce((best, value) => (value > best ? value : best), attemptFitnesses[0])
        : 0;
      const bestFitness = Number.isFinite(bestRaw) ? bestRaw : bestFromAttempts;
      return {
        generation: generationIndex,
        bestFitness: Number.isFinite(bestFitness) ? bestFitness : 0,
        attemptFitnesses,
      };
    }

    function replaceFitnessHistory(entries) {
      const normalized = Array.isArray(entries)
        ? entries.map(normalizeFitnessHistoryEntry).filter(Boolean)
        : [];
      normalized.sort((a, b) => a.generation - b.generation);
      const deduped = [];
      for (const entry of normalized) {
        const last = deduped[deduped.length - 1];
        if (last && last.generation === entry.generation) {
          deduped[deduped.length - 1] = entry;
        } else {
          deduped.push(entry);
        }
      }
      fitnessHistory = deduped;
      renderFitnessHistory();
    }

    function upsertFitnessHistoryEntry(source) {
      const entry = normalizeFitnessHistoryEntry(source);
      if (!entry) return;
      const last = fitnessHistory[fitnessHistory.length - 1];
      if (!last) {
        fitnessHistory.push(entry);
        renderFitnessHistory();
        return;
      }
      if (entry.generation > last.generation) {
        fitnessHistory.push(entry);
        renderFitnessHistory();
        return;
      }
      if (entry.generation === last.generation) {
        fitnessHistory[fitnessHistory.length - 1] = entry;
        renderFitnessHistory();
      }
    }

    async function refreshFitnessHistoryFromBackend() {
      if (fitnessHistoryRefreshInFlight) return;
      fitnessHistoryRefreshInFlight = true;
      const token = ++fitnessHistoryFetchToken;
      try {
        const response = await fetch(BACKEND_EVOLUTION_HISTORY_URL, { method: "GET" });
        if (!response.ok) {
          throw new Error(`history request failed (${response.status})`);
        }
        const payload = await response.json();
        if (token !== fitnessHistoryFetchToken) return;
        replaceFitnessHistory(payload?.history);
      } catch (error) {
        console.error("fitness history fetch failed", error);
      } finally {
        fitnessHistoryRefreshInFlight = false;
      }
    }

    async function hydrateEvolutionStateFromBackend() {
      try {
        const response = await fetch(BACKEND_EVOLUTION_STATE_URL, { method: "GET" });
        if (!response.ok) {
          throw new Error(`state request failed (${response.status})`);
        }
        const payload = await response.json();
        if (payload && typeof payload === "object") {
          applyEvolutionStatus(payload);
        }
      } catch (error) {
        console.warn("evolution state hydrate failed", error);
      }
    }

    function connectEvolutionSocket() {
      if (evolutionSocket && (evolutionSocket.readyState === WebSocket.CONNECTING || evolutionSocket.readyState === WebSocket.OPEN)) {
        return;
      }
      const socket = new WebSocket(BACKEND_EVOLUTION_WS_URL);
      evolutionSocket = socket;

      socket.addEventListener("open", () => {
        evolutionConnected = true;
        backendOfflineReason = "";
        void refreshFitnessHistoryFromBackend();
      });

      socket.addEventListener("message", (event) => {
        let msg;
        try {
          msg = JSON.parse(event.data);
        } catch (error) {
          console.error("evolution stream parse error", error);
          return;
        }
        if (msg.type === "status") {
          applyEvolutionStatus(msg.status || {});
          return;
        }
        if (msg.type === "generation_summary") {
          upsertFitnessHistoryEntry(msg.summary || msg);
          return;
        }
        if (msg.type === "trial_started") {
          const genome = msg.genome;
          if (!genome || typeof genome !== "object") {
            console.warn("evolution stream trial_started missing genome payload");
            return;
          }
          const existingFitness = Number(currentGenomeSnapshot?.fitness) || 0;
          currentGenomeSnapshot = {
            genome: cloneGenome(genome),
            fitness: existingFitness,
            index: currentAttemptIndex,
            source: "stream_trial_started",
          };
          clearPopulation();
          const view = new BackendCreatureView(0, genome, new THREE.Vector3(0, 0.05, 0));
          population.push(view);
          const partSizes = Array.isArray(msg.partSizes) ? msg.partSizes : (Array.isArray(msg.part_sizes) ? msg.part_sizes : []);
          if (partSizes.length > 0) {
            view.setPartSizes(partSizes);
          }
          return;
        }
        if (msg.type === "snapshot") {
          const view = getPrimaryBackendView();
          if (!view || !msg.frame) return;
          view.bufferFrame(msg.frame);
          return;
        }
        if (msg.type === "trial_complete") {
          const view = getPrimaryBackendView();
          if (!view) return;
          view.markTrialComplete(msg.result || null);
          return;
        }
        if (msg.type === "error") {
          console.error("evolution stream error", msg.message);
        }
      });

      socket.addEventListener("close", () => {
        if (evolutionSocket === socket) {
          evolutionSocket = null;
        }
        evolutionConnected = false;
        backendOfflineReason = "evolution stream disconnected";
        if (evolutionReconnectTimer) {
          clearTimeout(evolutionReconnectTimer);
        }
        evolutionReconnectTimer = setTimeout(() => {
          connectEvolutionSocket();
        }, 1200);
      });

      socket.addEventListener("error", (event) => {
        console.error("evolution websocket error", event);
        backendOfflineReason = "evolution stream transport error";
      });
    }

    function applyEvolutionStatus(status) {
      const minPopulationRaw = status.minPopulationSize ?? status.min_population_size;
      const maxPopulationRaw = status.maxPopulationSize ?? status.max_population_size;
      const defaultPopulationRaw = status.defaultPopulationSize ?? status.default_population_size;
      const defaultTrialRaw = status.defaultTrialCount ?? status.default_trial_count;
      const maxTrialRaw = status.maxTrialCount ?? status.max_trial_count;
      const defaultDurationRaw = status.defaultGenerationSeconds ?? status.default_generation_seconds;
      const minRunRaw = status.minRunSpeed ?? status.min_run_speed;
      const maxRunRaw = status.maxRunSpeed ?? status.max_run_speed;

      if (Number.isFinite(minPopulationRaw)) {
        minPopulationSize = Math.max(1, minPopulationRaw | 0);
      }
      if (Number.isFinite(maxPopulationRaw)) {
        maxPopulationSize = Math.max(1, maxPopulationRaw | 0);
      }
      if (maxPopulationSize < minPopulationSize) {
        maxPopulationSize = minPopulationSize;
      }
      if (Number.isFinite(defaultPopulationRaw)) {
        defaultPopulationSize = clamp(defaultPopulationRaw | 0, minPopulationSize, maxPopulationSize);
      } else {
        defaultPopulationSize = clamp(defaultPopulationSize, minPopulationSize, maxPopulationSize);
      }
      if (Number.isFinite(maxTrialRaw)) {
        maxTrialCount = Math.max(1, maxTrialRaw | 0);
      }
      if (Number.isFinite(defaultTrialRaw)) {
        defaultTrialCount = clamp(defaultTrialRaw | 0, 1, maxTrialCount);
      } else {
        defaultTrialCount = clamp(defaultTrialCount, 1, maxTrialCount);
      }
      if (Number.isFinite(defaultDurationRaw) && defaultDurationRaw > 0) {
        generationSeconds = Number(defaultDurationRaw);
      }
      if (Number.isFinite(minRunRaw)) {
        minRunSpeed = Math.max(0.1, Number(minRunRaw));
      }
      if (Number.isFinite(maxRunRaw)) {
        maxRunSpeed = Math.max(minRunSpeed, Number(maxRunRaw));
      }
      if (simSpeed < minRunSpeed || simSpeed > maxRunSpeed) {
        simSpeed = clamp(simSpeed, minRunSpeed, maxRunSpeed);
        speedSelect.value = String(simSpeed);
      }
      populationSlider.min = String(minPopulationSize);
      populationSlider.max = String(maxPopulationSize);

      const nextGeneration = Number.isFinite(status.generation) ? Math.max(1, status.generation | 0) : generation;
      if (nextGeneration < lastKnownGeneration) {
        fitnessHistory = [];
        renderFitnessHistory();
        void refreshFitnessHistoryFromBackend();
      }
      generation = nextGeneration;
      lastKnownGeneration = generation;
      populationSize = clamp((status.populationSize ?? status.population_size ?? populationSize) | 0, minPopulationSize, maxPopulationSize);
      pendingPopulationSize = clamp((status.pendingPopulationSize ?? status.pending_population_size ?? populationSize) | 0, minPopulationSize, maxPopulationSize);
      const nextTrialCountRaw = status.trialCount ?? status.trial_count;
      if (Number.isFinite(nextTrialCountRaw)) {
        trialsPerCandidate = clamp((nextTrialCountRaw | 0) || trialsPerCandidate, 1, maxTrialCount);
      }
      currentAttemptIndex = Math.max(0, (status.currentAttemptIndex ?? status.current_attempt_index ?? 0) | 0);
      currentTrialIndex = clamp(
        (status.currentTrialIndex ?? status.current_trial_index ?? 0) | 0,
        0,
        Math.max(0, trialsPerCandidate - 1)
      );
      bestEverScore = Number.isFinite(status.bestEverScore) ? status.bestEverScore : (Number.isFinite(status.best_ever_score) ? status.best_ever_score : bestEverScore);
      paused = Boolean(status.paused);
      const runSpeedRaw = status.runSpeed ?? status.run_speed;
      if (Number.isFinite(runSpeedRaw)) {
        simSpeed = clamp(Number(runSpeedRaw), minRunSpeed, maxRunSpeed);
        speedSelect.value = String(simSpeed);
      }
      const ffRemainingRaw = status.fastForwardRemaining ?? status.fast_forward_remaining;
      const ffActiveRaw = status.fastForwardActive ?? status.fast_forward_active;
      const queueRaw = status.injectionQueueCount ?? status.injection_queue_count;
      const satellitesRaw = status.connectedSatellites ?? status.connected_satellites;
      fastForwardGenerationsRemaining = Number.isFinite(ffRemainingRaw) ? Math.max(0, ffRemainingRaw | 0) : fastForwardGenerationsRemaining;
      backendFastForwardBusy = Boolean(ffActiveRaw);
      injectionQueueCount = Number.isFinite(queueRaw) ? Math.max(0, queueRaw | 0) : injectionQueueCount;
      if (Array.isArray(satellitesRaw)) {
        connectedSatellites = satellitesRaw.filter((id) => typeof id === "string");
      }
      const latestHistoryGeneration = fitnessHistory.length > 0
        ? fitnessHistory[fitnessHistory.length - 1].generation
        : 0;
      if (generation > latestHistoryGeneration + 1) {
        void refreshFitnessHistoryFromBackend();
      }
      if (Number.isFinite(status.currentScore ?? status.current_score)) {
        const score = Number(status.currentScore ?? status.current_score);
        const view = getPrimaryBackendView();
        if (view) {
          view.fitness = Math.max(view.fitness, score);
        }
      }
      const currentGenomePayload = status.currentGenome || status.current_genome;
      if (currentGenomePayload) {
        const genome = currentGenomePayload;
        if (genome) {
          const cloned = cloneGenome(genome);
          currentGenomeSnapshot = {
            genome: cloned,
            fitness: Number(status.currentScore ?? status.current_score ?? 0) || 0,
            index: currentAttemptIndex,
            source: "backend_current",
          };
        }
      } else {
        currentGenomeSnapshot = null;
      }
      const bestGenomePayload = status.bestGenome || status.best_genome;
      if (bestGenomePayload) {
        const genome = bestGenomePayload;
        if (genome) {
          bestGenomeSnapshot = {
            genome: cloneGenome(genome),
            fitness: bestEverScore,
            index: -1,
            source: "backend_best",
          };
        }
      } else {
        bestGenomeSnapshot = null;
      }
      populationSlider.value = String(pendingPopulationSize);
      populationSliderValue.textContent = String(pendingPopulationSize);
    }

    function getPrimaryBackendView() {
      if (population.length === 0) return null;
      const creature = population[0];
      return creature instanceof BackendCreatureView ? creature : null;
    }

    function syncBackendPlaybackClock() {
      const view = getPrimaryBackendView();
      if (!view) return;
      const frame = view.currentPlaybackFrame();
      if (!frame || !Number.isFinite(frame.time)) return;
      simClock = frame.time;
      generationClock = simClock;
    }

    function clearPopulation() {
      for (const creature of population) {
        creature.dispose();
      }
      population.length = 0;
    }

    function updateHud(champion) {
      generationLabel.textContent = String(generation);
      bestEverLabel.textContent = bestEverScore.toFixed(2);
      bestNowLabel.textContent = champion ? champion.fitness.toFixed(2) : "0.00";
      championLabel.textContent = String(Math.min(currentAttemptIndex + 1, populationSize));
      trialInfoLabel.textContent = `${Math.min(currentTrialIndex + 1, trialsPerCandidate)}/${trialsPerCandidate}`;
      simRateLabel.textContent = evolutionConnected
        ? `${effectiveSimSpeed.toFixed(2)}x (viewer)`
        : "0.00x (disconnected)";
      timeLeftLabel.textContent = Math.max(0, generationSeconds - generationClock).toFixed(1);
      const pendingText = pendingPopulationSize === populationSize ? "none" : `${pendingPopulationSize} (next gen)`;
      const injectionText = injectionQueueCount > 0 ? ` | inject ${injectionQueueCount}` : "";
      queuedPopLabel.textContent = `${pendingText}${injectionText}`;
      fastSkipStatusLabel.textContent = evolutionConnected
        ? (fastForwardGenerationsRemaining > 0
          ? `${fastForwardGenerationsRemaining} gens remaining${backendFastForwardBusy ? " (processing...)" : ""}`
          : "off")
        : `offline${backendOfflineReason ? `: ${backendOfflineReason}` : ""}`;
      satellitesLabel.textContent = connectedSatellites.length > 0
        ? `${connectedSatellites.length} connected: ${connectedSatellites.join(", ")}`
        : "none";
      pauseResumeBtn.textContent = paused ? "Resume" : "Pause";
    }

    function updateCamera(frameDelta, champion) {
      if (!champion) return;

      const framing = getPopulationFraming();
      const target = framing.center;
      const fov = THREE.MathUtils.degToRad(camera.fov);
      const distance = Math.max(16, (framing.radius + 8) / Math.tan(fov * 0.5));
      const desired = target.clone().add(new THREE.Vector3(distance * 0.9, distance * 0.6, distance * 0.9));

      if (performance.now() < cameraManualUntil) {
        controls.target.lerp(target, 0.16);
        controls.update();
        return;
      }

      camera.position.lerp(desired, 1 - Math.exp(-frameDelta * 2.8));
      controls.target.lerp(target, 1 - Math.exp(-frameDelta * 3.1));
      camera.lookAt(controls.target);
    }

    function getChampion() {
      if (population.length === 0) return null;
      const creature = population[0];
      return {
        genome: creature.genome,
        fitness: creature.fitness,
        index: currentAttemptIndex,
        torsoBody: creature.torsoBody,
      };
    }

    function getCurrentCandidate() {
      return currentGenomeSnapshot && currentGenomeSnapshot.genome ? currentGenomeSnapshot : null;
    }

    function getBestCandidate() {
      if (bestGenomeSnapshot && bestGenomeSnapshot.genome) {
        return bestGenomeSnapshot;
      }
      return currentGenomeSnapshot && currentGenomeSnapshot.genome ? currentGenomeSnapshot : null;
    }

    function getPopulationFraming() {
      if (population.length === 0) {
        return { center: new THREE.Vector3(0, 2.2, 0), radius: 8 };
      }
      let minX = Infinity;
      let minY = Infinity;
      let minZ = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let maxZ = -Infinity;
      for (const creature of population) {
        const p = creature.torsoBody.position;
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        minZ = Math.min(minZ, p.z);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
        maxZ = Math.max(maxZ, p.z);
      }
      const center = new THREE.Vector3((minX + maxX) * 0.5, (minY + maxY) * 0.5 + 1.4, (minZ + maxZ) * 0.5);
      let radius = 0;
      for (const creature of population) {
        const p = creature.torsoBody.position;
        const dx = p.x - center.x;
        const dy = p.y - center.y;
        const dz = p.z - center.z;
        radius = Math.max(radius, Math.hypot(dx, dy, dz));
      }
      return { center, radius: Math.max(6, radius) };
    }

    function updateSunShadowRig(frameDelta) {
      if (!sunLight) return;
      const framing = getPopulationFraming();
      const easing = 1 - Math.exp(-frameDelta * 2.4);
      sunTargetPos.copy(framing.center);
      sunDesiredPos.copy(sunTargetPos).add(sunOffset);

      sunLight.position.lerp(sunDesiredPos, easing);
      sunLight.target.position.lerp(sunTargetPos, easing);

      const span = Math.max(92, framing.radius * 3.3);
      sunLight.shadow.camera.left = -span;
      sunLight.shadow.camera.right = span;
      sunLight.shadow.camera.top = span;
      sunLight.shadow.camera.bottom = -span;
      sunLight.shadow.camera.far = Math.max(260, span * 4.4);
      sunLight.shadow.camera.updateProjectionMatrix();
      sunLight.target.updateMatrixWorld();
    }

    function markManualCamera() {
      cameraManualUntil = performance.now() + 7000;
    }

    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      composer.setSize(window.innerWidth, window.innerHeight);
      resizeGenomeCanvas();
      resizeFitnessHistoryCanvas();
    }

    function setGenomeVizVisibility(visible) {
      genomePanel.style.display = visible ? "block" : "none";
      if (visible && !genomeCollapsed) resizeGenomeCanvas();
    }

    function setHudCollapsed(collapsed) {
      hudCollapsed = Boolean(collapsed);
      hud.classList.toggle("collapsed", hudCollapsed);
      toggleHudBtn.textContent = hudCollapsed ? "Show" : "Hide";
    }

    function setGenomeCollapsed(collapsed) {
      genomeCollapsed = Boolean(collapsed);
      genomePanel.classList.toggle("collapsed", genomeCollapsed);
      toggleGenomeBtn.textContent = genomeCollapsed ? "Show" : "Hide";
      if (!genomeCollapsed && genomePanel.style.display !== "none") {
        resizeGenomeCanvas();
      }
    }

    function setFitnessHistoryCollapsed(collapsed) {
      fitnessHistoryCollapsed = Boolean(collapsed);
      fitnessHistoryPanel.classList.toggle("collapsed", fitnessHistoryCollapsed);
      toggleFitnessHistoryBtn.textContent = fitnessHistoryCollapsed ? "Show" : "Hide";
      if (!fitnessHistoryCollapsed) {
        resizeFitnessHistoryCanvas();
      }
    }

    function resizeGenomeCanvas() {
      const width = Math.max(1, Math.floor(genomeCanvas.clientWidth));
      const height = Math.max(1, Math.floor(genomeCanvas.clientHeight));
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      genomeCanvas.width = Math.max(1, Math.floor(width * dpr));
      genomeCanvas.height = Math.max(1, Math.floor(height * dpr));
      genomeCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function resizeFitnessHistoryCanvas() {
      const width = Math.max(1, Math.floor(fitnessHistoryCanvas.clientWidth));
      const height = Math.max(1, Math.floor(fitnessHistoryCanvas.clientHeight));
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      fitnessHistoryCanvas.width = Math.max(1, Math.floor(width * dpr));
      fitnessHistoryCanvas.height = Math.max(1, Math.floor(height * dpr));
      fitnessHistoryCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
      renderFitnessHistory();
    }

    function renderFitnessHistory() {
      const W = Math.max(1, Math.floor(fitnessHistoryCanvas.clientWidth));
      const H = Math.max(1, Math.floor(fitnessHistoryCanvas.clientHeight));
      const ctx = fitnessHistoryCtx;
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = "rgba(6, 10, 8, 0.46)";
      ctx.fillRect(0, 0, W, H);

      if (fitnessHistory.length === 0) {
        fitnessHistoryMeta.textContent = "Waiting for generation results...";
        ctx.fillStyle = "#b8d795";
        ctx.font = "12px Trebuchet MS, Segoe UI, sans-serif";
        ctx.fillText("Waiting for generation results...", 12, 22);
        return;
      }

      const PADDING_LEFT = 42;
      const PADDING_RIGHT = 12;
      const PADDING_TOP = 10;
      const PADDING_BOTTOM = 22;
      const plotW = Math.max(1, W - PADDING_LEFT - PADDING_RIGHT);
      const plotH = Math.max(1, H - PADDING_TOP - PADDING_BOTTOM);
      const maxVisible = Math.max(12, Math.floor(plotW / 3));
      const entries = fitnessHistory.slice(-maxVisible);

      let minFitness = Infinity;
      let maxFitness = -Infinity;
      for (const entry of entries) {
        for (const value of entry.attemptFitnesses) {
          minFitness = Math.min(minFitness, value);
          maxFitness = Math.max(maxFitness, value);
        }
        minFitness = Math.min(minFitness, entry.bestFitness);
        maxFitness = Math.max(maxFitness, entry.bestFitness);
      }
      if (!Number.isFinite(minFitness) || !Number.isFinite(maxFitness)) {
        minFitness = 0;
        maxFitness = 1;
      }
      const span = Math.max(1e-3, maxFitness - minFitness);
      const paddedMin = minFitness - span * 0.08;
      const paddedMax = maxFitness + span * 0.08;
      const den = Math.max(1e-3, paddedMax - paddedMin);

      const yForFitness = (fitness) =>
        PADDING_TOP + (1 - (fitness - paddedMin) / den) * plotH;
      const xForIndex = (index) =>
        PADDING_LEFT + (entries.length <= 1 ? 0 : (index / (entries.length - 1)) * plotW);

      const gridLines = 4;
      for (let i = 0; i <= gridLines; i++) {
        const y = PADDING_TOP + (i / gridLines) * plotH;
        ctx.strokeStyle = i === gridLines ? "rgba(170, 200, 120, 0.28)" : "rgba(170, 194, 117, 0.10)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(PADDING_LEFT, y);
        ctx.lineTo(W - PADDING_RIGHT, y);
        ctx.stroke();
      }

      ctx.fillStyle = "rgba(185, 214, 152, 0.82)";
      ctx.font = "10px Trebuchet MS, Segoe UI, sans-serif";
      ctx.fillText(paddedMax.toFixed(2), 4, PADDING_TOP + 3);
      ctx.fillText(paddedMin.toFixed(2), 4, H - PADDING_BOTTOM + 3);

      ctx.fillStyle = "rgba(215, 224, 206, 0.28)";
      for (let i = 0; i < entries.length; i++) {
        const x = xForIndex(i);
        const attempts = entries[i].attemptFitnesses;
        for (const value of attempts) {
          const y = yForFitness(value);
          ctx.beginPath();
          ctx.arc(x, y, 1.7, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.strokeStyle = "rgba(210, 240, 159, 0.94)";
      ctx.lineWidth = 1.8;
      ctx.beginPath();
      for (let i = 0; i < entries.length; i++) {
        const x = xForIndex(i);
        const y = yForFitness(entries[i].bestFitness);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      ctx.fillStyle = "rgba(217, 245, 168, 0.95)";
      for (let i = 0; i < entries.length; i++) {
        const x = xForIndex(i);
        const y = yForFitness(entries[i].bestFitness);
        ctx.beginPath();
        ctx.arc(x, y, 2.2, 0, Math.PI * 2);
        ctx.fill();
      }

      const last = entries[entries.length - 1];
      const first = entries[0];
      fitnessHistoryMeta.textContent =
        `gens ${first.generation}-${last.generation} | latest best ${last.bestFitness.toFixed(2)} | points ${fitnessHistory.length}`;
      ctx.fillStyle = "rgba(185, 214, 152, 0.82)";
      ctx.font = "10px Trebuchet MS, Segoe UI, sans-serif";
      ctx.fillText(`Gen ${first.generation}`, PADDING_LEFT, H - 6);
      const rightLabel = `Gen ${last.generation}`;
      const rightWidth = ctx.measureText(rightLabel).width;
      ctx.fillText(rightLabel, W - PADDING_RIGHT - rightWidth, H - 6);
    }

    function graphNodes(genome) {
      return Array.isArray(genome?.graph?.nodes) ? genome.graph.nodes : [];
    }

    function graphRootIndex(genome, nodes) {
      if (!nodes || nodes.length === 0) return 0;
      const raw = genome?.graph?.root;
      return clamp((raw | 0) || 0, 0, nodes.length - 1);
    }

    function graphEdges(node) {
      return Array.isArray(node?.edges) ? node.edges : [];
    }

    function localNeuronCount(node) {
      return Array.isArray(node?.brain?.neurons) ? node.brain.neurons.length : 0;
    }

    function summarizeGraphGenome(genome) {
      const nodes = graphNodes(genome);
      const root = graphRootIndex(genome, nodes);
      let edgeCount = 0;
      let ballEdges = 0;
      let hingeEdges = 0;
      let recursiveEdges = 0;
      let terminalEdges = 0;
      let reflectEdges = 0;
      let localNeurons = 0;
      let effectorGainSum = 0;
      let effectorGainCount = 0;
      let partMassApprox = 0;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i] || {};
        const part = node.part || {};
        const w = Number(part.w) || 0;
        const h = Number(part.h) || 0;
        const d = Number(part.d) || 0;
        const density = Number(part.mass) || 0;
        partMassApprox += Math.max(0, w * h * d * density);

        localNeurons += localNeuronCount(node);

        for (const key of ["effectorX", "effectorY", "effectorZ"]) {
          const gain = Number(node?.brain?.[key]?.gain);
          if (Number.isFinite(gain)) {
            effectorGainSum += Math.abs(gain);
            effectorGainCount += 1;
          }
        }

        for (const edge of graphEdges(node)) {
          edgeCount += 1;
          const jt = String(edge?.jointType ?? "hinge").toLowerCase();
          if (jt.includes("ball")) ballEdges += 1;
          else hingeEdges += 1;
          if (Boolean(edge?.terminalOnly)) terminalEdges += 1;
          if (Boolean(edge?.reflectX)) reflectEdges += 1;
          const to = clamp((edge?.to | 0) || 0, 0, Math.max(0, nodes.length - 1));
          const recursiveLimit = Math.max(1, (edge?.recursiveLimit | 0) || 1);
          if (recursiveLimit > 1 || to === i) recursiveEdges += 1;
        }
      }
      const globalNeurons = Array.isArray(genome?.graph?.globalBrain?.neurons)
        ? genome.graph.globalBrain.neurons.length
        : 0;
      const maxParts = Math.max(nodes.length, (genome?.graph?.maxParts | 0) || nodes.length);
      const meanEffectorGain = effectorGainCount > 0 ? effectorGainSum / effectorGainCount : 0;
      return {
        nodes,
        root,
        nodeCount: nodes.length,
        edgeCount,
        ballEdges,
        hingeEdges,
        recursiveEdges,
        terminalEdges,
        reflectEdges,
        localNeurons,
        globalNeurons,
        totalNeurons: localNeurons + globalNeurons,
        meanEffectorGain,
        maxParts,
        partMassApprox: partMassApprox * (Number(genome?.massScale) || 1),
      };
    }

    function computeGraphLayout(summary, ox, oy, W, H) {
      const nodes = summary.nodes;
      const n = nodes.length;
      const root = summary.root;
      const depth = Array.from({ length: n }, () => Number.POSITIVE_INFINITY);
      const queue = [];
      if (n > 0) {
        depth[root] = 0;
        queue.push(root);
      }
      while (queue.length > 0) {
        const from = queue.shift();
        const fromDepth = depth[from];
        const edges = graphEdges(nodes[from]);
        for (const edge of edges) {
          const to = clamp((edge?.to | 0) || 0, 0, n - 1);
          if (!Number.isFinite(depth[to]) || depth[to] > fromDepth + 1) {
            depth[to] = fromDepth + 1;
            queue.push(to);
          }
        }
      }
      let maxDepth = 0;
      for (let i = 0; i < n; i++) {
        if (!Number.isFinite(depth[i])) {
          depth[i] = maxDepth + 1;
        }
        maxDepth = Math.max(maxDepth, depth[i]);
      }
      const byDepth = new Map();
      for (let i = 0; i < n; i++) {
        const d = depth[i] | 0;
        if (!byDepth.has(d)) byDepth.set(d, []);
        byDepth.get(d).push(i);
      }
      const padX = 20;
      const padY = 22;
      const usableW = Math.max(1, W - padX * 2);
      const usableH = Math.max(1, H - padY * 2);
      const positions = Array.from({ length: n }, () => ({ x: ox + W * 0.5, y: oy + H * 0.5 }));
      for (const [d, list] of byDepth.entries()) {
        const x = ox + padX + (maxDepth <= 0 ? 0.5 : d / maxDepth) * usableW;
        const count = list.length;
        for (let j = 0; j < count; j++) {
          const idx = list[j];
          const y = oy + padY + ((j + 1) / (count + 1)) * usableH;
          positions[idx] = { x, y };
        }
      }
      return { depth, maxDepth, positions };
    }

    function renderGenomeViz(bestCandidate, currentCandidate) {
      const vizCreature = genomeVizMode === "current" ? currentCandidate : bestCandidate;
      const W = Math.max(1, Math.floor(genomeCanvas.clientWidth));
      const H = Math.max(1, Math.floor(genomeCanvas.clientHeight));
      const ctx = genomeCtx;
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = "rgba(6, 10, 8, 0.46)";
      ctx.fillRect(0, 0, W, H);
      vizDrawGrid(ctx, W, H);

      if (!vizCreature || !vizCreature.genome) {
        ctx.fillStyle = "#b8d795";
        ctx.font = "12px Trebuchet MS, Segoe UI, sans-serif";
        const waitingText = genomeVizMode === "current"
          ? "Current genome snapshot not available yet."
          : "Best genome snapshot not available yet.";
        ctx.fillText(waitingText, 12, 20);
        genomeMeta.textContent = "Waiting for backend genome snapshots.";
        genomeTitle.textContent = genomeVizMode === "current"
          ? "Current Genome Analysis (V2 Graph/Neural)"
          : "Best Genome Analysis (V2 Graph/Neural)";
        return;
      }

      const genome = vizCreature.genome;
      const summary = summarizeGraphGenome(genome);

      const topH = Math.floor(H * 0.62);
      const bottomY = topH;
      const bottomH = H - bottomY;
      const leftW = Math.floor(W * 0.5);

      vizDrawV2Topology(ctx, genome, summary, 0, 0, W, topH);
      vizDrawSeparator(ctx, W, bottomY);
      vizDrawV2StructureStats(ctx, summary, 8, bottomY + 6, leftW - 12, bottomH - 10);
      vizDrawV2NeuralStats(ctx, summary, leftW + 4, bottomY + 6, W - leftW - 10, bottomH - 10);

      const score = Number(vizCreature.fitness) || 0;
      const tag = Number.isFinite(vizCreature.index) && vizCreature.index >= 0
        ? `#${vizCreature.index + 1}`
        : "BEST";
      ctx.fillStyle = "rgba(208, 233, 156, 0.92)";
      ctx.font = "11px Trebuchet MS, Segoe UI, sans-serif";
      ctx.textAlign = "right";
      ctx.fillText(tag, W - 10, 14);
      ctx.fillText(`Score ${score.toFixed(2)}`, W - 10, 28);
      ctx.textAlign = "left";

      genomeTitle.textContent = genomeVizMode === "current"
        ? "Current Genome Analysis (V2 Graph/Neural)"
        : "Best Genome Analysis (V2 Graph/Neural)";
      genomeMeta.textContent =
        `nodes ${summary.nodeCount} | edges ${summary.edgeCount} | maxParts ${summary.maxParts} | ` +
        `neurons ${summary.localNeurons}/${summary.globalNeurons} (local/global) | ` +
        `recursive ${summary.recursiveEdges} | est mass ${summary.partMassApprox.toFixed(1)} kg`;
    }

    function vizDrawGrid(ctx, W, H) {
      const grid = 28;
      ctx.strokeStyle = "rgba(170, 194, 117, 0.06)";
      ctx.lineWidth = 1;
      for (let x = 0; x < W; x += grid) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
      for (let y = 0; y < H; y += grid) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }
    }

    function vizDrawSeparator(ctx, W, y) {
      ctx.strokeStyle = "rgba(170, 200, 120, 0.18)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(6, y);
      ctx.lineTo(W - 6, y);
      ctx.stroke();
    }

    function vizDrawSectionLabel(ctx, text, x, y) {
      ctx.save();
      ctx.font = "bold 8.5px Trebuchet MS, Segoe UI, sans-serif";
      ctx.fillStyle = "rgba(180, 210, 140, 0.45)";
      ctx.letterSpacing = "1.2px";
      ctx.fillText(text, x, y);
      ctx.restore();
    }

    function vizDrawV2Topology(ctx, genome, summary, ox, oy, W, H) {
      vizDrawSectionLabel(ctx, "GRAPH MORPHOLOGY", 8, oy + 12);
      const nodes = summary.nodes;
      if (nodes.length === 0) {
        ctx.fillStyle = "rgba(190, 215, 150, 0.68)";
        ctx.font = "11px Trebuchet MS, Segoe UI, sans-serif";
        ctx.fillText("No graph nodes available.", ox + 10, oy + 44);
        return;
      }
      const layout = computeGraphLayout(summary, ox, oy, W, H);
      const pulse = 0.5 + 0.5 * Math.sin(simClock * 1.35);

      for (let i = 0; i < nodes.length; i++) {
        const from = layout.positions[i];
        for (const edge of graphEdges(nodes[i])) {
          const toIndex = clamp((edge?.to | 0) || 0, 0, nodes.length - 1);
          const to = layout.positions[toIndex];
          const jointType = String(edge?.jointType ?? "hinge").toLowerCase();
          const isBall = jointType.includes("ball");
          const terminalOnly = Boolean(edge?.terminalOnly);
          const reflectX = Boolean(edge?.reflectX);
          const recursiveLimit = Math.max(1, (edge?.recursiveLimit | 0) || 1);
          const recursive = recursiveLimit > 1 || toIndex === i;
          const bend = recursive ? 24 : 0;
          const cpx = (from.x + to.x) * 0.5 + bend;
          const cpy = (from.y + to.y) * 0.5 + (from.y < to.y ? -8 : 8);
          ctx.save();
          ctx.strokeStyle = isBall
            ? `rgba(108, 204, 235, ${0.34 + pulse * 0.26})`
            : `rgba(232, 184, 102, ${0.34 + pulse * 0.26})`;
          ctx.lineWidth = reflectX ? 2.0 : 1.2;
          if (terminalOnly) ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.quadraticCurveTo(cpx, cpy, to.x, to.y);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        }
      }

      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const partMass = Number(node?.part?.mass) || 0.4;
        const neurons = localNeuronCount(node);
        const p = layout.positions[i];
        const radius = 4 + clamp(partMass / 1.4, 0, 1) * 6;
        const neuronGlow = clamp(neurons / 12, 0, 1);
        const isRoot = i === summary.root;
        ctx.save();
        ctx.fillStyle = isRoot
          ? `rgba(208, 233, 156, ${0.7 + pulse * 0.2})`
          : `rgba(162, 206, 128, ${0.25 + neuronGlow * 0.45})`;
        ctx.strokeStyle = isRoot ? "rgba(232, 248, 192, 0.95)" : "rgba(182, 214, 150, 0.55)";
        ctx.lineWidth = isRoot ? 1.8 : 1.0;
        ctx.beginPath();
        ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.font = "8px Trebuchet MS, sans-serif";
        ctx.fillStyle = "rgba(8, 14, 10, 0.92)";
        ctx.textAlign = "center";
        ctx.fillText(String(i), p.x, p.y + 2.5);
        ctx.restore();
      }

      ctx.save();
      ctx.font = "8px Trebuchet MS, sans-serif";
      ctx.fillStyle = "rgba(186, 214, 151, 0.58)";
      ctx.textAlign = "left";
      ctx.fillText("Hinge edges", ox + W - 120, oy + 14);
      ctx.fillStyle = "rgba(232, 184, 102, 0.85)";
      ctx.fillRect(ox + W - 138, oy + 8, 12, 2);
      ctx.fillStyle = "rgba(186, 214, 151, 0.58)";
      ctx.fillText("Ball edges", ox + W - 120, oy + 28);
      ctx.fillStyle = "rgba(108, 204, 235, 0.85)";
      ctx.fillRect(ox + W - 138, oy + 22, 12, 2);
      ctx.restore();
    }

    function vizDrawStatBar(ctx, label, value, ox, oy, W, hue) {
      const h = 8;
      const barW = Math.max(12, W - 66);
      const x = ox + 62;
      const y = oy;
      const v = clamp(value, 0, 1);
      ctx.save();
      ctx.font = "7.5px Trebuchet MS, sans-serif";
      ctx.fillStyle = "rgba(186, 214, 151, 0.62)";
      ctx.textAlign = "right";
      ctx.fillText(label, x - 4, y + h - 1);
      ctx.fillStyle = "rgba(96, 122, 80, 0.2)";
      vizRoundRect(ctx, x, y, barW, h, 2);
      ctx.fill();
      ctx.fillStyle = `hsla(${hue}, 54%, 58%, 0.82)`;
      vizRoundRect(ctx, x, y, Math.max(1, barW * v), h, 2);
      ctx.fill();
      ctx.restore();
    }

    function vizDrawV2StructureStats(ctx, summary, ox, oy, W, H) {
      vizDrawSectionLabel(ctx, "MORPH STRUCTURE", ox, oy + 10);
      const maxEdges = Math.max(1, summary.nodeCount * 4);
      const bars = [
        { label: "node usage", value: summary.maxParts > 0 ? summary.nodeCount / summary.maxParts : 0, hue: 138 },
        { label: "edge density", value: summary.edgeCount / maxEdges, hue: 82 },
        { label: "recursive", value: summary.edgeCount > 0 ? summary.recursiveEdges / summary.edgeCount : 0, hue: 34 },
        { label: "symmetry", value: summary.edgeCount > 0 ? summary.reflectEdges / summary.edgeCount : 0, hue: 198 },
        { label: "ball joints", value: summary.edgeCount > 0 ? summary.ballEdges / summary.edgeCount : 0, hue: 215 },
        { label: "mass est", value: clamp(summary.partMassApprox / 80, 0, 1), hue: 262 },
      ];
      const rowGap = 3;
      const rowH = 8;
      const startY = oy + 16;
      for (let i = 0; i < bars.length; i++) {
        vizDrawStatBar(ctx, bars[i].label, bars[i].value, ox, startY + i * (rowH + rowGap), W, bars[i].hue);
      }
    }

    function vizDrawV2NeuralStats(ctx, summary, ox, oy, W, H) {
      vizDrawSectionLabel(ctx, "NEURAL CONTROLLER", ox, oy + 10);
      const nodeNeuronCapacity = Math.max(1, summary.nodeCount * 12);
      const bars = [
        { label: "local neurons", value: summary.localNeurons / nodeNeuronCapacity, hue: 144 },
        { label: "global neurons", value: summary.globalNeurons / 14, hue: 90 },
        { label: "total neurons", value: summary.totalNeurons / Math.max(14, nodeNeuronCapacity + 14), hue: 36 },
        { label: "fanout", value: summary.nodeCount > 0 ? summary.edgeCount / (summary.nodeCount * 4) : 0, hue: 192 },
        { label: "effector gain", value: summary.meanEffectorGain / 2.2, hue: 265 },
        { label: "terminal edges", value: summary.edgeCount > 0 ? summary.terminalEdges / summary.edgeCount : 0, hue: 22 },
      ];
      const rowGap = 3;
      const rowH = 8;
      const startY = oy + 16;
      for (let i = 0; i < bars.length; i++) {
        vizDrawStatBar(ctx, bars[i].label, bars[i].value, ox, startY + i * (rowH + rowGap), W, bars[i].hue);
      }

      const infoY = startY + bars.length * (rowH + rowGap) + 2;
      ctx.save();
      ctx.font = "7px Trebuchet MS, sans-serif";
      ctx.fillStyle = "rgba(186, 214, 151, 0.58)";
      ctx.textAlign = "left";
      ctx.fillText(`nodes ${summary.nodeCount} | edges ${summary.edgeCount} | maxParts ${summary.maxParts}`, ox + 2, infoY);
      ctx.fillText(`hinge ${summary.hingeEdges} | ball ${summary.ballEdges} | recursive ${summary.recursiveEdges}`, ox + 2, infoY + 10);
      ctx.restore();
    }

    function vizRoundRect(ctx, x, y, w, h, r) {
      r = Math.min(r, w * 0.5, h * 0.5);
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.arcTo(x + w, y, x + w, y + r, r);
      ctx.lineTo(x + w, y + h - r);
      ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
      ctx.lineTo(x + r, y + h);
      ctx.arcTo(x, y + h, x, y + h - r, r);
      ctx.lineTo(x, y + r);
      ctx.arcTo(x, y, x + r, y, r);
      ctx.closePath();
    }

    function createSky() {
      const sky = new THREE.Mesh(
        new THREE.SphereGeometry(420, 40, 20),
        new THREE.ShaderMaterial({
          side: THREE.BackSide,
          uniforms: {
            topColor: { value: new THREE.Color(0xa8b1c0) },
            bottomColor: { value: new THREE.Color(0xe7d6bc) },
          },
          vertexShader: `
            varying vec3 vWorldPosition;
            void main() {
              vec4 worldPosition = modelMatrix * vec4(position, 1.0);
              vWorldPosition = worldPosition.xyz;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
          `,
          fragmentShader: `
            varying vec3 vWorldPosition;
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            void main() {
              float h = clamp(normalize(vWorldPosition).y * 0.5 + 0.5, 0.0, 1.0);
              float t = smoothstep(0.08, 1.0, h);
              gl_FragColor = vec4(mix(bottomColor, topColor, t), 1.0);
            }
          `,
        })
      );
      scene.add(sky);
    }

    function createTerrain() {
      const texture = buildGroundTexture();
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.set(84, 84);
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

      const floorMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(840, 840),
        new THREE.MeshStandardMaterial({
          color: 0x9ab06f,
          map: texture,
          roughness: 0.97,
          metalness: 0.02,
        })
      );
      floorMesh.rotation.x = -Math.PI * 0.5;
      floorMesh.receiveShadow = true;
      scene.add(floorMesh);

      const mountainMaterial = new THREE.MeshStandardMaterial({
        color: 0x5a5d54,
        roughness: 0.93,
        metalness: 0.05,
      });
      // Mountains are visual-only meshes; no physics bodies are created for them.
      for (let i = 0; i < 82; i++) {
        const angle = (i / 82) * Math.PI * 2 + randRange(-0.05, 0.05);
        const radius = randRange(235, 390);
        const height = randRange(22, 74);
        const width = randRange(12, 28);
        const mountain = new THREE.Mesh(
          new THREE.ConeGeometry(width, height, 4 + ((i % 5) + 1)),
          mountainMaterial
        );
        mountain.position.set(Math.cos(angle) * radius, height * 0.5 - 0.2, Math.sin(angle) * radius);
        mountain.rotation.y = randRange(0, Math.PI * 2);
        mountain.castShadow = true;
        mountain.receiveShadow = true;
        scene.add(mountain);
      }
    }

    function createOriginMarker() {
      // Visual-only start marker (no physics collision).
      const marker = new THREE.Group();
      marker.position.set(0, 0, 0);

      const ring = new THREE.Mesh(
        new THREE.RingGeometry(1.25, 1.75, 40),
        new THREE.MeshStandardMaterial({
          color: 0xe7f5b8,
          emissive: 0x2d3c1f,
          emissiveIntensity: 0.3,
          roughness: 0.4,
          metalness: 0.15,
          side: THREE.DoubleSide,
        })
      );
      ring.rotation.x = -Math.PI * 0.5;
      ring.position.y = 0.012;
      ring.receiveShadow = true;
      marker.add(ring);

      const pole = new THREE.Mesh(
        new THREE.CylinderGeometry(0.05, 0.05, 2.2, 12),
        new THREE.MeshStandardMaterial({
          color: 0x5d4a2f,
          roughness: 0.72,
          metalness: 0.08,
        })
      );
      pole.position.set(0, 1.1, 0);
      pole.castShadow = true;
      marker.add(pole);

      const finial = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 12, 8),
        new THREE.MeshStandardMaterial({
          color: 0xf4e8be,
          emissive: 0x554f2b,
          emissiveIntensity: 0.18,
          roughness: 0.42,
          metalness: 0.12,
        })
      );
      finial.position.set(0, 2.25, 0);
      finial.castShadow = true;
      marker.add(finial);

      const flag = new THREE.Mesh(
        new THREE.PlaneGeometry(0.9, 0.5),
        new THREE.MeshStandardMaterial({
          color: 0xb8d46f,
          emissive: 0x334422,
          emissiveIntensity: 0.22,
          roughness: 0.6,
          metalness: 0.05,
          side: THREE.DoubleSide,
        })
      );
      flag.position.set(0.47, 1.95, 0);
      flag.castShadow = true;
      marker.add(flag);

      const spriteCanvas = document.createElement("canvas");
      spriteCanvas.width = 256;
      spriteCanvas.height = 96;
      const sctx = spriteCanvas.getContext("2d");
      sctx.fillStyle = "rgba(10, 14, 11, 0.7)";
      sctx.fillRect(0, 0, spriteCanvas.width, spriteCanvas.height);
      sctx.strokeStyle = "rgba(202, 227, 146, 0.9)";
      sctx.lineWidth = 4;
      sctx.strokeRect(2, 2, spriteCanvas.width - 4, spriteCanvas.height - 4);
      sctx.fillStyle = "#e1f6b4";
      sctx.font = "bold 44px Trebuchet MS";
      sctx.textAlign = "center";
      sctx.textBaseline = "middle";
      sctx.fillText("START", spriteCanvas.width * 0.5, spriteCanvas.height * 0.52);
      const spriteTexture = new THREE.CanvasTexture(spriteCanvas);
      spriteTexture.colorSpace = THREE.SRGBColorSpace;
      const label = new THREE.Sprite(
        new THREE.SpriteMaterial({
          map: spriteTexture,
          transparent: true,
          depthTest: true,
          depthWrite: false,
        })
      );
      label.position.set(0, 2.85, 0);
      label.scale.set(2.6, 0.95, 1);
      marker.add(label);

      scene.add(marker);
    }

    function createLighting() {
      scene.add(new THREE.HemisphereLight(0xdde7f5, 0x6a6f57, 0.52));

      sunLight = new THREE.DirectionalLight(0xffe7c7, 1.28);
      sunLight.position.copy(sunOffset);
      sunLight.castShadow = true;
      sunLight.shadow.mapSize.set(4096, 4096);
      sunLight.shadow.camera.near = 1;
      sunLight.shadow.camera.far = 560;
      sunLight.shadow.camera.left = -180;
      sunLight.shadow.camera.right = 180;
      sunLight.shadow.camera.top = 180;
      sunLight.shadow.camera.bottom = -180;
      sunLight.shadow.normalBias = 0.018;
      sunLight.shadow.bias = -0.00012;
      scene.add(sunLight);
      scene.add(sunLight.target);
    }

    function buildGroundTexture() {
      const canvas = document.createElement("canvas");
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext("2d");

      const gradient = ctx.createLinearGradient(0, 0, 512, 512);
      gradient.addColorStop(0, "#5e7d45");
      gradient.addColorStop(0.5, "#90aa62");
      gradient.addColorStop(1, "#7d9958");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);

      for (let i = 0; i < 4600; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const size = 2 + Math.random() * 6;
        const alpha = 0.02 + Math.random() * 0.08;
        ctx.fillStyle = Math.random() > 0.5 ? `rgba(57, 82, 39, ${alpha})` : `rgba(178, 195, 132, ${alpha})`;
        ctx.fillRect(x, y, size, size);
      }
      return new THREE.CanvasTexture(canvas);
    }

    class BackendCreatureView {
      constructor(index, genome, spawnPoint) {
        this.index = index;
        this.genome = cloneGenome(genome);
        this.spawnPoint = new THREE.Vector3(spawnPoint.x, spawnPoint.y, spawnPoint.z);
        this.parts = [];
        this.fitness = 0;
        this.lastSampleTime = null;
        this.torsoBody = {
          position: new THREE.Vector3(spawnPoint.x, spawnPoint.y + 5, spawnPoint.z),
        };
        this.snapshotBuffer = [];
        this.playbackTime = 0;
        this.playbackIndex = 0;
        this.lastAppliedPlaybackIndex = -1;
        this.trialComplete = false;
        this.trialResult = null;
        this.completionDispatched = false;
        this.distanceLabel = null;
        this.distanceLabelCanvas = null;
        this.distanceLabelCtx = null;
        this.distanceLabelTexture = null;
        this.lastDistanceText = "";
      }

      setPartSizes(partSizes) {
        this.disposeMeshes();
        const hue = (this.genome.hue + 1) % 1;
        const baseColor = new THREE.Color().setHSL(hue, 0.63, 0.3);
        const midColor = baseColor.clone().offsetHSL(0.01, -0.06, 0.04);
        const darkColor = baseColor.clone().offsetHSL(0.02, -0.12, -0.08);

        for (let i = 0; i < partSizes.length; i++) {
          const size = partSizes[i];
          const color = i === 0 ? baseColor : (i === 1 ? midColor : darkColor);
          const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(size[0], size[1], size[2]),
            new THREE.MeshStandardMaterial({
              color,
              roughness: 0.64,
              metalness: 0.08,
            })
          );
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          scene.add(mesh);
          this.parts.push(mesh);
        }
        this._createDistanceLabel();
      }

      _createDistanceLabel() {
        this._disposeDistanceLabel();
        const canvas = document.createElement("canvas");
        canvas.width = 256;
        canvas.height = 80;
        const ctx = canvas.getContext("2d");
        const texture = new THREE.CanvasTexture(canvas);
        texture.colorSpace = THREE.SRGBColorSpace;
        const sprite = new THREE.Sprite(
          new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: true,
            depthWrite: false,
          })
        );
        sprite.scale.set(2.4, 0.75, 1);
        scene.add(sprite);
        this.distanceLabel = sprite;
        this.distanceLabelCanvas = canvas;
        this.distanceLabelCtx = ctx;
        this.distanceLabelTexture = texture;
        this.lastDistanceText = "";
        this._drawDistanceLabel("0.00m");
      }

      _drawDistanceLabel(text) {
        if (text === this.lastDistanceText) return;
        this.lastDistanceText = text;
        const ctx = this.distanceLabelCtx;
        const w = this.distanceLabelCanvas.width;
        const h = this.distanceLabelCanvas.height;
        ctx.clearRect(0, 0, w, h);
        const r = 10;
        ctx.beginPath();
        ctx.moveTo(r, 0);
        ctx.lineTo(w - r, 0);
        ctx.quadraticCurveTo(w, 0, w, r);
        ctx.lineTo(w, h - r);
        ctx.quadraticCurveTo(w, h, w - r, h);
        ctx.lineTo(r, h);
        ctx.quadraticCurveTo(0, h, 0, h - r);
        ctx.lineTo(0, r);
        ctx.quadraticCurveTo(0, 0, r, 0);
        ctx.closePath();
        ctx.fillStyle = "rgba(10, 14, 11, 0.72)";
        ctx.fill();
        ctx.strokeStyle = "rgba(183, 208, 112, 0.6)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "#e1f6b4";
        ctx.font = "bold 36px Trebuchet MS";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, w * 0.5, h * 0.52);
        this.distanceLabelTexture.needsUpdate = true;
      }

      _disposeDistanceLabel() {
        if (this.distanceLabel) {
          scene.remove(this.distanceLabel);
          this.distanceLabel.material.dispose();
          if (this.distanceLabelTexture) this.distanceLabelTexture.dispose();
          this.distanceLabel = null;
          this.distanceLabelCanvas = null;
          this.distanceLabelCtx = null;
          this.distanceLabelTexture = null;
        }
      }

      applyFrame(frame) {
        const bodies = frame.bodies || [];
        const count = Math.min(this.parts.length, bodies.length);
        for (let i = 0; i < count; i++) {
          const mesh = this.parts[i];
          const body = bodies[i];
          mesh.position.set(body.p[0], body.p[1], body.p[2]);
          mesh.quaternion.set(body.q[0], body.q[1], body.q[2], body.q[3]);
        }
        if (count > 0) {
          const torso = bodies[0];
          this.torsoBody.position.set(torso.p[0], torso.p[1], torso.p[2]);
          this.lastSampleTime = frame.time;
          if (this.distanceLabel) {
            this.distanceLabel.position.set(torso.p[0], torso.p[1] + 3.5, torso.p[2]);
            const dx = torso.p[0] - this.spawnPoint.x;
            const dz = torso.p[2] - this.spawnPoint.z;
            const dist = Math.sqrt(dx * dx + dz * dz);
            this._drawDistanceLabel(dist.toFixed(2) + "m");
          }
        }
        if (Number.isFinite(frame.score)) {
          this.fitness = Math.max(this.fitness, frame.score);
        }
      }

      bufferFrame(frame) {
        this.snapshotBuffer.push(frame);
        if (Number.isFinite(frame.score)) {
          this.fitness = Math.max(this.fitness, frame.score);
        }
      }

      markTrialComplete(result) {
        this.trialComplete = true;
        this.trialResult = result || null;
        if (result && Number.isFinite(result.fitness)) {
          this.fitness = Math.max(this.fitness, result.fitness);
        }
      }

      hasPendingPlayback() {
        if (this.snapshotBuffer.length === 0) {
          return this.trialComplete && !this.completionDispatched;
        }
        return !this.trialComplete || this.playbackIndex < this.snapshotBuffer.length - 1 || !this.completionDispatched;
      }

      currentPlaybackFrame() {
        if (this.snapshotBuffer.length === 0) return null;
        return this.snapshotBuffer[this.playbackIndex] || null;
      }

      advancePlayback(wallDelta, speed) {
        if (this.snapshotBuffer.length === 0) return;
        if (Number.isFinite(speed) && speed > 0) {
          this.playbackTime += wallDelta * speed;
        }
        const lastFrame = this.snapshotBuffer[this.snapshotBuffer.length - 1];
        if (this.trialComplete && lastFrame && Number.isFinite(lastFrame.time)) {
          this.playbackTime = Math.min(this.playbackTime, lastFrame.time);
        }
        while (
          this.playbackIndex < this.snapshotBuffer.length - 1 &&
          this.snapshotBuffer[this.playbackIndex + 1].time <= this.playbackTime
        ) {
          this.playbackIndex += 1;
        }
        if (this.lastAppliedPlaybackIndex !== this.playbackIndex) {
          this.applyFrame(this.snapshotBuffer[this.playbackIndex]);
          this.lastAppliedPlaybackIndex = this.playbackIndex;
        }
      }

      consumeCompletedTrialResult() {
        if (this.completionDispatched || !this.trialComplete) return null;
        if (this.snapshotBuffer.length > 0 && this.playbackIndex < this.snapshotBuffer.length - 1) {
          return null;
        }
        this.completionDispatched = true;
        return this.trialResult || {
          fitness: this.fitness,
          metrics: this.getTrialSummary(generationSeconds),
        };
      }

      getTrialSummary(durationSeconds) {
        return {
          quality: this.fitness,
          progress: this.fitness,
          uprightAvg: 0,
          avgHeight: 0,
          instabilityNorm: 0,
          energyNorm: 0,
          fallenRatio: 0,
          straightness: 0,
          netDistance: this.fitness,
        };
      }

      disposeMeshes() {
        for (const mesh of this.parts) {
          scene.remove(mesh);
          mesh.geometry.dispose();
          mesh.material.dispose();
        }
        this.parts.length = 0;
        this._disposeDistanceLabel();
      }

      dispose() {
        this.disposeMeshes();
      }
    }

    function cloneGenome(genome) {
      if (!genome || typeof genome !== "object") return genome;
      if (typeof structuredClone === "function") {
        try {
          return structuredClone(genome);
        } catch (_) {
          // fall through to JSON clone
        }
      }
      return JSON.parse(JSON.stringify(genome));
    }

    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    void (async () => {
      await hydrateEvolutionStateFromBackend();
      connectEvolutionSocket();
    })();
  </script>
</body>

</html>
